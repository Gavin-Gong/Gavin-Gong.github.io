{"meta":{"title":"Feway","subtitle":null,"description":null,"author":"Gavin-Gong","url":"http://gavin-gong.github.io"},"pages":[{"title":"About","date":"2016-10-04T07:12:10.621Z","updated":"2016-10-04T07:12:10.621Z","comments":true,"path":"about/index.html","permalink":"http://gavin-gong.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-10-04T07:12:10.635Z","updated":"2016-10-04T07:12:10.635Z","comments":true,"path":"tags/index.html","permalink":"http://gavin-gong.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-10-04T07:12:10.628Z","updated":"2016-10-04T07:12:10.628Z","comments":true,"path":"categories/index.html","permalink":"http://gavin-gong.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"yarn学习","slug":"yarn","date":"2016-10-18T08:59:15.864Z","updated":"2016-10-18T10:25:05.559Z","comments":true,"path":"2016/10/18/yarn/","link":"","permalink":"http://gavin-gong.github.io/2016/10/18/yarn/","excerpt":"","text":"安装官网下载msi文件安装, 或者npm命令行安装, 安装完成后遇到cmd里面找不到命令的问题, 需要找到他的安装目录添加到系统变量, 在MinGW会出现如下错误, 用cmd就好了.Can&#39;t answer a question unless a user TTY查看yarn config get registry设置淘宝源yarn config set registry &#39;https://registry.npm.taobao.org&#39; 基本命令 yarn init或者yarn 初始化 yarn add &lt;pkg-name&gt; 添加依赖 yarn add &lt;pkg-name&gt; --dev 添加开发依赖 yarn remove &lt;pkg-name&gt; 删除依赖 yarn upgrade &lt;pkg-name&gt; 升级依赖 yarn run 列出可以执行的命令 yarn run &lt;script&gt; 执行 yarn ls 列出所有依赖 参考yarn 错误","categories":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}],"tags":[{"name":"node","slug":"node","permalink":"http://gavin-gong.github.io/tags/node/"}],"keywords":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}]},{"title":"迷之抓虫","slug":"迷之抓虫","date":"2016-10-14T14:14:57.113Z","updated":"2016-10-14T14:32:05.606Z","comments":true,"path":"2016/10/14/迷之抓虫/","link":"","permalink":"http://gavin-gong.github.io/2016/10/14/迷之抓虫/","excerpt":"","text":"今天花了几个小时修了个公司项目的bug，起因是这样， 公司老板拿去测试发现文本框输入文本， 在失去焦点之后输入的内容就没了, 另外我看老板发的截图发现这个样式也有点不对, 尽管在电脑上测试一切正常, 在手机端的chrome也一切正常, 就在微信端和QQ浏览器会出现这种神奇的bug, 我表示很无语, 因为确信我没写过这种清空输入框的代码, 其他人应该也不会, 因为这个项目的与表单有关的基本都是我在做, 然后开始了抓虫之旅, 由于是单页应用为了方便测试我直接通过连接到那个出现bug的页面, 然后发现一切正常, 我就有点懵逼了, 然后我从开始页面进去, 一步步点进那个页面, 发现bug又出现了, 我开始猜测是不是中间有哪个页面做了什么不该做的事情, 所幸的是我又发现有一个页面跳转到bug页面并不会出现bug, 一切正常, 就是这么任性, 我…… 我开始猜测是不是跳转过来的页面导致的bug, 然后我就开始一段一段地注释代码, 一次又一次地刷新浏览器, 终于定位到bug所在之处, 大概代码如下 12&lt;input type=\"radio\" name=\"sex\" value=\"男\" v-el:man&gt;&lt;input type=\"radio\" name=\"sex\" value=\"女\" v-el:female&gt; 我通过API 获取性别, 然后通过v-el来获取DOM元素设置某一个性别为默认值 123// 省略了一些语句this.$els.man.setAttribute('checked', '');this.$els.female.setAttribute('checked', ''); 在vue里面, 其实这样的写法很傻, vue 的核心思想是数据驱, 一般不直接操作DOM. 我发现只要不进行DOM 操作就一切正常, 也就是说删除上面的代码, 那么原先的bug页面就一切正常, 然后我就开始想会不会是v-el的原因, 我给html加了个class 通过js来设置checked属性, 写完之后刷新还是发现不行, 懵逼ing…. 最后走投无路, 想可不可以换个方式设置checked属性, 而不是操作DOM,然后代码变成了这样 12&lt;input type=\"radio\" name=\"sex\" :checked=\"sex === '男'\" value=\"男\"&gt;&lt;input type=\"radio\" name=\"sex\" :checked=\"sex === '女'\" value=\"女\"&gt; 然后刷新页面, bug修复完成. 尽管修复了bug, 但是还是没有找到为什么之前的代码会导致后一个页面的样式改变和输入框失去焦点清空输入的问题, 还是感觉到很憋屈…… 总结 文档很重要, 要仔细看. 抛开这里场景不说, 后面一种的写法无疑要比之前的写法清晰很多, 这他妈还是官方示例啊 bug快速定位分析 ps之前那几篇找时间完善一下","categories":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://gavin-gong.github.io/tags/Vue/"}],"keywords":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}]},{"title":"promise","slug":"promise","date":"2016-10-13T12:38:36.006Z","updated":"2016-10-14T01:14:41.942Z","comments":true,"path":"2016/10/13/promise/","link":"","permalink":"http://gavin-gong.github.io/2016/10/13/promise/","excerpt":"","text":"1234567891011121314151617let promise = new Promise((rsv, rjct) =&gt; &#123; if (/*condition*/) &#123; rsv() //如果rsv()函数带参数, 会传递给下一个then &#125; else &#123; rjct() ////如果rjct()函数带参数, 会传递给下一个then, 或者catch函数 &#125;&#125;)promise.then(data =&gt; console.log(data), err =&gt; console.log(err))// 或者promise.then(data =&gt; console.log(data)).catch(err =&gt; console.log(err))// data 为rsv()函数带的参数, 为空则data为undefined// err 为reject()函数带的参数,// 链式调用promise.then(data =&gt; data).then(data =&gt; data)// promise值得传递, resolve()函数通过自己的参数传递给第一个then的第一个函数参数, (第二个函数参数接受的是reject()传递的参数), 如果then往后面的then传递数据, 将要传的数据return下去, 上面是箭头函数的写法, 可以省略rturn APIpromise.prototype.then()promise.prototype.resolve()promise.prototype.reject()promise.prototype.all()promise.prototype.race()参考es6入门","categories":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://gavin-gong.github.io/tags/es6/"}],"keywords":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}]},{"title":"fetch","slug":"fetch-api","date":"2016-10-11T04:21:49.795Z","updated":"2016-10-14T01:14:39.793Z","comments":true,"path":"2016/10/11/fetch-api/","link":"","permalink":"http://gavin-gong.github.io/2016/10/11/fetch-api/","excerpt":"","text":"fetch api1234567891011fetch('url', &#123; method: 'POST', headers: &#123; 'Content-Type': 'text/plain', &#125;, // ......&#125;).then(res =&gt; &#123; &#125;).catch( err =&gt; &#123; &#125;);","categories":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://gavin-gong.github.io/tags/es6/"}],"keywords":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}]},{"title":"async/await","slug":"async-wait","date":"2016-10-10T12:06:50.548Z","updated":"2016-10-14T01:14:47.503Z","comments":true,"path":"2016/10/10/async-wait/","link":"","permalink":"http://gavin-gong.github.io/2016/10/10/async-wait/","excerpt":"","text":"async/await await只能用于async函数中 await后面一般接一个promise对象，如不是promise对象, 则失去异步调用的作用 async总是返回一个promise对象, 所以你可以在后面接then() 并发1234567async function foo () &#123; let [a, b, c] = await Promise.all([p1, p2, p3]); // a, b, c 是对象promise对象执行后的resolve值 // 或者这样 // const all = Promise.all.bind(Promise); // let [a, b, c] = await all([p1, p2, p3]);&#125; 错误处理123asyncFunction() .then() .catch(err =&gt; console.log(err)) 循环多个await如果要循环多个await 要注意async 的上下文,await要始终保持在它的上下文中, 123456789[1, 2, 3].forEach( v =&gt; &#123; await sleep(1000); // 这里的await并没有在`async`函数上下文中&#125;)// 正确写法, 用for循环for (let i of [1, 2, 3]) &#123; await sleep(1000);&#125; awaitawait后面接一个promise对象, 如果不是则不执行异步, 想到Promise.resolve()可以将转化为promise对象, 试了试如下代码 123456789101112function timeout(ms) &#123; setTimeout(() =&gt; console.log('timeout'), ms)&#125;async function asyncPrint(value, ms) &#123; await Promise.resolve(timeout(ms)); console.log(value)&#125;asyncPrint('hello world', 50); // 'hello world'// 'timeout' 并没有什么卵用.","categories":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://gavin-gong.github.io/tags/es6/"}],"keywords":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}]}]}