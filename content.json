{"meta":{"title":"Feway","subtitle":null,"description":null,"author":"Gavin-Gong","url":"http://gavin-gong.github.io"},"pages":[{"title":"Tags","date":"2016-10-04T07:12:10.635Z","updated":"2016-10-04T07:12:10.635Z","comments":true,"path":"tags/index.html","permalink":"http://gavin-gong.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-10-04T07:12:10.628Z","updated":"2016-10-04T07:12:10.628Z","comments":true,"path":"categories/index.html","permalink":"http://gavin-gong.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2016-10-19T01:42:58.225Z","updated":"2016-10-19T01:42:58.225Z","comments":true,"path":"about/index.html","permalink":"http://gavin-gong.github.io/about/index.html","excerpt":"","text":"对互联网世界和UI设计充满兴趣的设计狗，好奇计算机的世界, 直到某天突发奇想：直接用代码画UI ，从此一发不可收拾，在前端的路上渐行渐远，长路漫漫，唯码作伴。希望成为一位前端工程师来提高自己的技术。"}],"posts":[{"title":"最近写代码的心态","slug":"最近的学习心态","date":"2016-11-18T11:09:16.593Z","updated":"2016-11-18T11:31:08.399Z","comments":true,"path":"2016/11/18/最近的学习心态/","link":"","permalink":"http://gavin-gong.github.io/2016/11/18/最近的学习心态/","excerpt":"","text":"将近二十天没有写博客了, 这段时间一值在忙着学后端 (Express), 没时间写博客, 等项目写完会会解决掉遗留的问题, 写几篇博客总结. 这将近二十天学习中, 从前端进入后端的世界, 因为之前写过SPA, 前端SPA的路由与后端的路由处理有着不小的相似之处, 又用的是Node又让难度降低不少. 因此一直想尽快把自己边学边写的项目尽快完成, 补完后端的短板再好好回过头搞前端, 因为想到前端自己还是有太多的东西不懂, 然后导致最近写代码心态有点炸毛, 每天整个人都有点抑郁了 ==! 后来想起古龙小说中叶孤城的一句话 你既学剑，就该知道学剑的人只要诚于剑，并不必诚于人 对事物的追求都应该是追求其本身, 而非他的附加价值. 这样在整个过程中就能享受到更多的快乐. 自勉之!","categories":[{"name":"随感","slug":"随感","permalink":"http://gavin-gong.github.io/categories/随感/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://gavin-gong.github.io/tags/学习/"}],"keywords":[{"name":"随感","slug":"随感","permalink":"http://gavin-gong.github.io/categories/随感/"}]},{"title":"vue-router 笔记","slug":"vue-router-note","date":"2016-10-30T02:35:13.848Z","updated":"2016-11-01T10:52:37.803Z","comments":true,"path":"2016/10/30/vue-router-note/","link":"","permalink":"http://gavin-gong.github.io/2016/10/30/vue-router-note/","excerpt":"","text":"今天状态不佳, 只好看下vue-router的文档, 做下笔记, 平时很多自己遇到的问题其实都可以在文档里面找到答案的. 安装并使用 对于模块化开发 1234import Vue from 'vue';import VueRouter from 'vue-router';Vue.use(VueRouter); 平常开发 直接引用就好, 不过要注意标签先后顺序. tips 在使用路由匹配时,类似article/:id, 原先的组件实例会被复用, 这意味着原先组件的生命周期钩子函数created()等等 不会被调用, 这时候可以考虑路由钩子函数和watch $route对象的变化 高级路由匹配 -&gt; path-to-regexp 路由匹配优先级 -&gt; 同一路径可以匹配多个路由, 优先级按照定义先后顺序来, 举个例子, 平时定义的404路由一般放最后面. 当前面的路径都无法匹配到才会匹配到它. 12345&#123; path: '*', name: '404', component: not-found,&#125; 如果一个路由包括子路由, 那么可以考虑将它的路径设置为从根路径开始/user/:id, 子路由的路径就可以简短设置为profile, 无需嵌套很长的路径 一个路由包括多个子路由, 如果想让他默认渲染某个子路由的话可以这样写 123children: [ &#123;path: '', component: Profile&#125;,] 不过按照我的想法在路由设置redirect属性指向某个子路由也是可以的, 根据之前的例子 12345678910&#123; path: '/user/:id', redirect: 'profile', // 不知道这样行不行, redirect: &#123;name: 'profile'&#125; // 这样应该可以 redirect: '/user/:id/profile' // 这样? children: [ &#123;path: 'profile', component: Profile, name: 'profile' &#125;, ]&#125;// 实验了下, 好像都不行 ==! 什么鬼? 编程式导航 和vue-router 1.0不同的是, 以前的跳转是this.$route.router.go(...)现在是this.$router.push(...) router.replace(path)等同于 &lt;router-link :to=&quot;path&quot; replace&gt; 不会留下历史记录 命名视图 使用场景: 一个页面同时有多个router-view 1234567891011&lt;router-view name=\"one\"&gt;&lt;/router-view&gt;&lt;router-view name=\"two\"&gt;&lt;/router-view&gt;&#123; path: '/', components: [ default: Foo, a: bar, b: baz, ],&#125; 重定向 redirect可以是字符串, 对象, 甚至是函数 12345redirect: to =&gt; &#123; // 接收目标路由作为参数 // 返回重定向对象或字符串 return &#125; history mode 如果不想要很丑url模式可以设置, 然后url就会像正常url, 例如www.youtube.com/user/id. 但是需要后台配置, 学node+express再试试 1234new VueRouter(&#123; mode: 'history', route,&#125;) 导航钩子函数 beforeEach()和afterEach()这两个函数好像没什么变化, 另外afterEach是没有next()钩子的 12345router.beforeEach((to, from, next) =&gt; &#123; // next() 执行下一个钩子函数 // next(false) 中断当前导航 // next(path) 跳转到另外的页面&#125;) 某个路由独享钩子 to, from实际上是一个$route对象. 在路由配置上直接定义 1234567&#123; path: '/', component: Component, beforeEnter: (to, from ,next) &#123; &#125;,&#125; 或者在组件内定义钩子 12345678910beforeRouteEnter (to, from, next) =&gt; &#123; // 无法访问this, 因为组件实例还未被创建, 可以传一个回调给next来访问组件实例 next(vm =&gt; &#123; // 访问vm vm.postMethod(); &#125;)&#125;afterRouteEnter (to, from, next) =&gt; &#123; // 可以访问this&#125; 路由元信息新玩意, 设置代码如下， 可以通过$route.matched.requireAuth访问, 钩子函数中的to, from实际上就是一个$route对象, meta 用来配置权限非常有用, 记得1.0 是没没有单独选项的1234567&#123; path: '/', component: Login, meta: &#123; requireAuth: true, &#125;,&#125; 滚动行为只能在HTML5 history模式下有用, savedPosition当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用1234567891011const router = new VueRouter(&#123; routes: [], scrollBehavior (to, from, savedPosition) &#123; return &#123;x: 0, y:0&#125; // 或者 return &#123;selector: '#app'&#125; // 返回一个选择器 return &#123;selector: to.hash&#125; // 滚动到锚点 return false // 不滚动 return &#123;&#125; // 不滚动 &#125;,&#125;) lazy load让路由组件在访问的时候才被加载.AMD 风格1const component = reslove =&gt; require(['./foo.vue'], reslove); webpack语法1234567const Foo = resolve =&gt; &#123; require.ensure(['./Foo.vue'], () =&gt; &#123; resolve(require('./Foo.vue')) &#125;)&#125;// 这样简洁一点const Foo = r =&gt; require.ensure(['./Foo.vue'], () =&gt; r(require('./Foo.vue'))) ###组件按组分块如果要将某个路由的所有组件打包在某个异步的chunk中, 可以这样写12const Foo = r =&gt; require.ensure([], () =&gt; resolve(require('./Foo.vue')), 'group: loginpage')const Bar = r =&gt; require.ensure([], () =&gt; resolve(require('./Foo.vue')), 'group: loginpage') Webpack 将相同 chunk 下的所有异步模块打包到一个异步块里面 —— 这也意味着我们无须明确列出 require.ensure 的依赖（传空数组就行）。","categories":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://gavin-gong.github.io/tags/Vue/"}],"keywords":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}]},{"title":"写个爬虫, 爬取学校招聘信息","slug":"crawler","date":"2016-10-29T09:06:58.172Z","updated":"2016-10-29T09:52:36.202Z","comments":true,"path":"2016/10/29/crawler/","link":"","permalink":"http://gavin-gong.github.io/2016/10/29/crawler/","excerpt":"","text":"自从前几天的某一天晚上梦到尤教主之后, 不知道是不是因为尤教主在梦里对我太冷淡了, 我这几天都没有写Vue的冲动 ==; 然后我就闲来无事边学 Node 边写爬虫来抓取学校的招聘信息. 使用的模块: cheerio superagent superagent-charset json2xls json2csv 期间遇到数据写不进去, 写进去乱码的问题, 最后放弃这个模块, 用了上面那个 思路:获取招聘列表页数 -&gt; 获取所有列表 -&gt; 获取id -&gt; 获取所有招聘公司详情 -&gt; 提取检索数据 -&gt; 生成excel文件 遇到的问题: 中文乱码 -&gt; 见下 请求的先后顺序 -&gt; promise 模块使用问题 -&gt; 更换模块 ==; 解决方法 乱码: 一般的网页是utf-8编码, 学校的网址用的是gbk, 所以要安装superagent-charset模块指定编码 ==! 12345// 引入let charset = require('charset');let superagent = charset(require('superagent'))superagent.get(url).charset('gbk').then(...) // 指定编码let $ = cheerio(html, &#123;decodeEntities: false&#125;) // 禁止 cheerio对数据进行处理 渣渣代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293let charset = require('superagent-charset'), superagent = charset(require('superagent')), cheerio = require('cheerio');let fs = require('fs');let json2xls = require('json2xls');let listBaseUrl = 'http://stu.hnust.edu.cn/jy/jiuyeIndex.do?method=toCategoryZPH&amp;byzd=TYPE16&amp;pageNo='; // 加page数let detailBaseUrl = 'http://stu.hnust.edu.cn/jy/jiuyeIndex.do?method=showZphInfo2&amp;id='; // 加id -&gt; 访问详情页superagent .get(`$&#123;listBaseUrl&#125;1`) .charset('gbk') .then((res) =&gt; &#123; // 获取总页数 let $ = cheerio.load(res.text, &#123;decodeEntities: false&#125;); let pageNum = $('.blue-14 a').eq(1).attr('href').match(/\\'[0-9]+\\'/g)[0].replace(/\\'/g, ''); return pageNum; &#125;) .then(pageNum =&gt; &#123; // 获取访问所有的列表页由于获取id列表 let promiseList = []; for (let i = 0; i &lt; parseInt(pageNum); i ++) &#123; console.log(`$&#123;listBaseUrl + i&#125;`); promiseList[i] = superagent.get(`$&#123;listBaseUrl&#125;$&#123;i+1&#125;`).charset('gbk'); &#125; // console.log(promiseList); return Promise.all(promiseList); &#125;) .then(resList =&gt; &#123; // 根据resList 返回id列表 let idList = []; resList.forEach(item =&gt; &#123; var $ = cheerio.load(item.text, &#123;decodeEntities: false&#125;); console.log('pageNum', $('.xwmb-1 ~ div ul #li1 a').length); $('.xwmb-1 ~ div ul #li1 a').each(function (index) &#123; let id = $(this).attr('href').match(/\\'[0-9a-zA-Z]+\\'/g)[0].replace(/\\'/g, '') idList.push(id); &#125;); &#125;) return idList &#125;) .then(idList =&gt; &#123; // 根据idList 返回所有详情页的原始数据 let promiseList = [] for (let i = 0; i &lt; idList.length; i++) &#123; promiseList[i] = superagent.get(`$&#123;detailBaseUrl + idList[i]&#125;`).charset('gbk'); &#125; return Promise.all(promiseList); &#125;).then(incDetailList =&gt; &#123; // 提取数据 let dataList = []; incDetailList.forEach(data =&gt; &#123; let $ = cheerio.load(data.text, &#123;decodeEntities: false&#125;); // 获取时间 let date = $('.xian2').last().text().replace('招聘时间：', ''); // 地点 // console.log(date); let address = $('.xian2').first().text().replace('招聘地点：', ''); // 公司名字 let incName = $('.zlan2').text().replace(/\\（[0-9\\u4e00-\\u9fa5]+\\）/, ''); // 获取文本 let text = $('.xwmb-1 + div table').eq(4).text().replace(/[\\s]/g, ''); dataList.push(&#123; date: date, address: address, incName: incName, link: data.request.url, text: text &#125;); &#125;); return dataList; &#125;) .then(data =&gt; &#123; // 筛选数据， 输出csv文件 let reg = new RegExp(/web前端|ui设计|[^a-zA-Z\\/]web[^a-zA-Z\\/]|前端[\\u4e00-\\u9fa5\\s]+|[^a-zA-Z]ui[\\u4e00-\\u9fa5\\s]+/, 'gi'); let result = data.filter(item =&gt; &#123; let matchedResult = item.text.match(reg); delete item.text; if (matchedResult) &#123; item.star = matchedResult.length; return true; &#125; else &#123; return false; &#125; &#125;); let xls = json2xls(result); fs.writeFileSync('data.xlsx', xls, 'binary'); &#125;)// 思路// 获取总页数 -&gt; 获取所有公司id列表-&gt; 获取单个公司名字 &amp; 日期*n -&gt; 检索关键字 -&gt; 生成列表 后话因为用了promise没有陷入callback hell, 整个流程是用then串起来的, 但是你如果不写注释, 你会发现你压根就不知道then里面做了什么事, 最好的方案当然是async/await, 刚好Node 7发布, 宣布支持async/await, 兴冲冲地升级, 想用async/await写来着, 悲催地发现我另外一个vue的项目的node-sass不支持, 又不想搞babel编译, 所以不得已放弃治疗.","categories":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://gavin-gong.github.io/tags/Node/"}],"keywords":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}]},{"title":"一次奇葩的面试和反思","slug":"about-interview","date":"2016-10-24T13:25:54.389Z","updated":"2016-10-29T10:04:21.030Z","comments":true,"path":"2016/10/24/about-interview/","link":"","permalink":"http://gavin-gong.github.io/2016/10/24/about-interview/","excerpt":"","text":"前言前几天校招投的简历经过筛选, 今天跑过去面试结果经历了一次奇葩的面试. 面试上来先简单自我介绍, 然后面试官看了下我的简历, 让我介绍一下Vue, 刚开始我还以为她是要考我Vue, 然后我就巴拉巴拉说了一堆, 拿jQuery做了下对比, 我还猜想公司可能是写Vue的, 后来的交谈中我提到: ‘这个组件是我写的’, 然后她用一种奇怪的口吻说: ‘你不是做前端的吗? 怎么还写后端?’, 我然后给她解释了一下: ‘前端也可以组件化……’. 最后她跟我说Vue很少有人用吧! 然后又说我会的框架有点少, 我有点懵逼, 心中想了下: 难道还要会React和Angular? 我问了下他们公司的前端技术, 感情人家用的Bootstrap 和 jQuery, 我用了点鄙视的口气说(就是这么耿直), Boostrap用起来很简单, 不就是记class嘛! jQuery跟原生开发没太大的区别, Vue比jQuery难……然后她好像有点生气, 让我回去等通知, 我知道我肯定被刷了. 回去仔细一想(反射弧就是这么长), 情商为负的我总算明白了, 这面试官压根就不知道Vue, 不知道Vue….. 我的心灵受到一千点伤害. MD, 难道说技术也存在代沟??? 反思我的情商还需要练练 ==; 说话不能这么直白, 鄙视别人所珍视的东西就是在作死 ==; 技术鄙视要不得, 这估计就是一句php是世界上最好的语言引发战争的原因. 对各种技术要保持尊重, 内在要谦虚才是. 说什么是最好的根本毫无意义. 这几天的在无聊写爬虫的时候发现 jQuery还是挺好用的. 尽管我还是觉得组件化开发比较爽!","categories":[{"name":"随感","slug":"随感","permalink":"http://gavin-gong.github.io/categories/随感/"}],"tags":[{"name":"工作","slug":"工作","permalink":"http://gavin-gong.github.io/tags/工作/"}],"keywords":[{"name":"随感","slug":"随感","permalink":"http://gavin-gong.github.io/categories/随感/"}]},{"title":"求职心态的变化以及计划","slug":"find-job","date":"2016-10-22T10:59:41.660Z","updated":"2016-10-22T11:24:35.054Z","comments":true,"path":"2016/10/22/find-job/","link":"","permalink":"http://gavin-gong.github.io/2016/10/22/find-job/","excerpt":"","text":"离开学校实习的这两个月, 无声无息中错过秋招的最佳时间, 回到学校, 赶上招聘的末班车. 回来的这几天, 内心总是有些许惶恐, 会因为非计算机专业而自卑, 前端, 一直以来都是自己自学, 也不知道和科班出身的差距有多少.今天双选会, 招前端的公司也没有想象的那么多, 也只有一两家, 抱着试一试的心态投了一家, 然后回来等面试通知. 看着隔壁寝室的好几个签了合同, 自己的心态也有些波动了. 无论能不能在秋招找到一份自己满意的工作, 都要保持良好的心态, 好好把前端学好, 在明年春招的时候一定可以找到一份好工作. 在放寒假之前需要熟练的技术: [] vue2 全家桶 -&gt; 8 [] es2015 + node -&gt; 15 -&gt; 爬虫 [] express + jade + bootstrap + mongodb -&gt; 30 -&gt; blog [] jQuery &amp; Javascript -&gt; 15 [] 深入HTML 5 -&gt; 15 [] 深入CSS 3 -&gt; 15 初步估计大概到月底完成熟悉vue2的目标, es2015 和 node 同时进行. 以后根据具体时间调整. 闲暇之余可以研究再深入SASS, 探索一下PostCss","categories":[{"name":"随感","slug":"随感","permalink":"http://gavin-gong.github.io/categories/随感/"}],"tags":[{"name":"工作","slug":"工作","permalink":"http://gavin-gong.github.io/tags/工作/"}],"keywords":[{"name":"随感","slug":"随感","permalink":"http://gavin-gong.github.io/categories/随感/"}]},{"title":"gulp学习","slug":"gulp-learn","date":"2016-10-18T10:36:19.992Z","updated":"2016-10-18T14:23:34.111Z","comments":true,"path":"2016/10/18/gulp-learn/","link":"","permalink":"http://gavin-gong.github.io/2016/10/18/gulp-learn/","excerpt":"","text":"前言前两个月在公司实习, 在切图的流程中, css预处理器我用的是sass,每次都要开两个窗口, 一个编译’sass’, 然后又用另一个窗口运行’browser-sync’插件来监听文件的变化来刷新浏览器, 现在离职, 有时间来学习下gulp, 写个自己的工作流来提升开发效率.预期实现功能: 编译sass css自动添加前缀 -&gt; autoprefixer 编译es6 -&gt; babel 自动刷新浏览器 -&gt; browser-sync 使用安装yarn global add gulp-cliyarn add gulp --dev API一览总共四个api: gulp.src(), gulp.task(), gulp.dest, gulp.watch. gulp.src(globs[, options])globs可以是文件名数组和字符串,options对象有四个参数可以配置: buffer, read, base,该api后面可以连接管道操作,123gulp.src(['a.js', 'b.js', 'c.js'], &#123;buffer: false&#125;) .pipe(minify()) .pipe(gulp.dest('build')); glup.dest(path[, options])写入文件, 可以进行管道操作,path写入文件路径options有两个选项 cwd输出文件夹, 默认process.cwd(), mode关于读写权限的. gulp.task(name[, deps][, fn])一般配置一个任务,123gulp.task('sass', ['task', 'name', 'of', 'array'], () =&gt; &#123; // do stuff&#125;); name自定义用户名deps,任务数组, 这些任务将会在你定义的任务之前运行,fn, 定义该任务的主要操作忽略函数12gulp.task('sass', ['task', 'name', 'of', 'array']);// 这些任务将会并发执行 gulp.watch(glob[, opts], tasks) or gulp.watch(glob [, opts, cb])globs 上同tasks 任务列表了解了个大概! 配置文件在项目根目录下新建一个gulpfile.js文件, 然后开写! 12345var gulp = require('gulp');gulp.task('default', () =&gt; &#123;&#125;); 添加插件我们还需要安装一些需要的插件插件列表 gulp-sass gulp-autoprefixer gulp-babel browser-syncyarn add &lt;pkg-name&gt; --dev 在配置babel编译时, 出现了点小错误Error: Couldn&#39;t find preset &quot;es2015&quot; relative to directory &quot;/Users/username&quot;最终在stackoverflow上找到解决方案yarn add babel-preset-es2015 --dev然后在配置文件中引入var es2015 = require(&#39;babel-preset-es2015&#39;);gulp.task(&#39;es2015&#39;, () =&gt; gulp.src(&#39;./src/js/**/*&#39;).pipe(babel({ presets: [es2015] })).pipe(gulp.dest(&#39;./dist/js&#39;))); 整体思路将编辑的文件放在src目录, 将最终生成的文件放在dist目录, 开启一个本地服务器, 将文件处理后(或者直接)拷贝到dist,完成初始化, 然后监听src目录下的各种文件, 一旦有变化, 就进行相应的编译或者复制工作, 将结果输出到dist目录, 一旦dist目录下的文件被改变会触发浏览器刷新. 运行最终代码在此gulpfile.js 后话很渣的一个gulp配置文件, 从性能上考虑, 没有必要的在dist和src目录都监听. 更好的思路应该是: 初始化完成后, 一旦在src目录监听到变化, 等处理工作完成, 刷新浏览器.","categories":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}],"tags":[{"name":"node","slug":"node","permalink":"http://gavin-gong.github.io/tags/node/"}],"keywords":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}]},{"title":"yarn学习","slug":"yarn","date":"2016-10-18T08:59:15.864Z","updated":"2016-10-18T10:29:00.351Z","comments":true,"path":"2016/10/18/yarn/","link":"","permalink":"http://gavin-gong.github.io/2016/10/18/yarn/","excerpt":"","text":"安装官网下载msi文件安装, 或者npm命令行安装, 安装完成后遇到cmd里面找不到命令的问题, 需要找到他的安装目录添加到系统变量, 在MinGW会出现如下错误, 用cmd就好了.Can&#39;t answer a question unless a user TTY查看yarn config get registry设置淘宝源yarn config set registry &#39;https://registry.npm.taobao.org&#39; 基本命令 yarn init或者yarn 初始化 yarn add &lt;pkg-name&gt; 添加依赖 yarn add &lt;pkg-name&gt; --dev 添加开发依赖 yarn remove &lt;pkg-name&gt; 删除依赖 yarn upgrade &lt;pkg-name&gt; 升级依赖 yarn run 列出可以执行的命令 yarn run &lt;script&gt; 执行 yarn ls 列出所有依赖 参考yarn官网yarn 错误新的 js 包管理工具 yarn 解决了什么问题","categories":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}],"tags":[{"name":"node","slug":"node","permalink":"http://gavin-gong.github.io/tags/node/"}],"keywords":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}]},{"title":"迷之抓虫","slug":"迷之抓虫","date":"2016-10-14T14:14:57.113Z","updated":"2016-10-14T14:32:05.606Z","comments":true,"path":"2016/10/14/迷之抓虫/","link":"","permalink":"http://gavin-gong.github.io/2016/10/14/迷之抓虫/","excerpt":"","text":"今天花了几个小时修了个公司项目的bug，起因是这样， 公司老板拿去测试发现文本框输入文本， 在失去焦点之后输入的内容就没了, 另外我看老板发的截图发现这个样式也有点不对, 尽管在电脑上测试一切正常, 在手机端的chrome也一切正常, 就在微信端和QQ浏览器会出现这种神奇的bug, 我表示很无语, 因为确信我没写过这种清空输入框的代码, 其他人应该也不会, 因为这个项目的与表单有关的基本都是我在做, 然后开始了抓虫之旅, 由于是单页应用为了方便测试我直接通过连接到那个出现bug的页面, 然后发现一切正常, 我就有点懵逼了, 然后我从开始页面进去, 一步步点进那个页面, 发现bug又出现了, 我开始猜测是不是中间有哪个页面做了什么不该做的事情, 所幸的是我又发现有一个页面跳转到bug页面并不会出现bug, 一切正常, 就是这么任性, 我…… 我开始猜测是不是跳转过来的页面导致的bug, 然后我就开始一段一段地注释代码, 一次又一次地刷新浏览器, 终于定位到bug所在之处, 大概代码如下 12&lt;input type=\"radio\" name=\"sex\" value=\"男\" v-el:man&gt;&lt;input type=\"radio\" name=\"sex\" value=\"女\" v-el:female&gt; 我通过API 获取性别, 然后通过v-el来获取DOM元素设置某一个性别为默认值 123// 省略了一些语句this.$els.man.setAttribute('checked', '');this.$els.female.setAttribute('checked', ''); 在vue里面, 其实这样的写法很傻, vue 的核心思想是数据驱, 一般不直接操作DOM. 我发现只要不进行DOM 操作就一切正常, 也就是说删除上面的代码, 那么原先的bug页面就一切正常, 然后我就开始想会不会是v-el的原因, 我给html加了个class 通过js来设置checked属性, 写完之后刷新还是发现不行, 懵逼ing…. 最后走投无路, 想可不可以换个方式设置checked属性, 而不是操作DOM,然后代码变成了这样 12&lt;input type=\"radio\" name=\"sex\" :checked=\"sex === '男'\" value=\"男\"&gt;&lt;input type=\"radio\" name=\"sex\" :checked=\"sex === '女'\" value=\"女\"&gt; 然后刷新页面, bug修复完成. 尽管修复了bug, 但是还是没有找到为什么之前的代码会导致后一个页面的样式改变和输入框失去焦点清空输入的问题, 还是感觉到很憋屈…… 总结 文档很重要, 要仔细看. 抛开这里场景不说, 后面一种的写法无疑要比之前的写法清晰很多, 这他妈还是官方示例啊 bug快速定位分析 ps之前那几篇找时间完善一下","categories":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://gavin-gong.github.io/tags/Vue/"}],"keywords":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}]},{"title":"promise","slug":"promise","date":"2016-10-13T12:38:36.006Z","updated":"2016-10-14T01:14:41.942Z","comments":true,"path":"2016/10/13/promise/","link":"","permalink":"http://gavin-gong.github.io/2016/10/13/promise/","excerpt":"","text":"1234567891011121314151617let promise = new Promise((rsv, rjct) =&gt; &#123; if (/*condition*/) &#123; rsv() //如果rsv()函数带参数, 会传递给下一个then &#125; else &#123; rjct() ////如果rjct()函数带参数, 会传递给下一个then, 或者catch函数 &#125;&#125;)promise.then(data =&gt; console.log(data), err =&gt; console.log(err))// 或者promise.then(data =&gt; console.log(data)).catch(err =&gt; console.log(err))// data 为rsv()函数带的参数, 为空则data为undefined// err 为reject()函数带的参数,// 链式调用promise.then(data =&gt; data).then(data =&gt; data)// promise值得传递, resolve()函数通过自己的参数传递给第一个then的第一个函数参数, (第二个函数参数接受的是reject()传递的参数), 如果then往后面的then传递数据, 将要传的数据return下去, 上面是箭头函数的写法, 可以省略rturn APIpromise.prototype.then()promise.prototype.resolve()promise.prototype.reject()promise.prototype.all()promise.prototype.race()参考es6入门","categories":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://gavin-gong.github.io/tags/es6/"}],"keywords":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}]},{"title":"fetch","slug":"fetch-api","date":"2016-10-11T04:21:49.795Z","updated":"2016-10-14T01:14:39.793Z","comments":true,"path":"2016/10/11/fetch-api/","link":"","permalink":"http://gavin-gong.github.io/2016/10/11/fetch-api/","excerpt":"","text":"fetch api1234567891011fetch('url', &#123; method: 'POST', headers: &#123; 'Content-Type': 'text/plain', &#125;, // ......&#125;).then(res =&gt; &#123; &#125;).catch( err =&gt; &#123; &#125;);","categories":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://gavin-gong.github.io/tags/es6/"}],"keywords":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}]},{"title":"async/await","slug":"async-wait","date":"2016-10-10T12:06:50.548Z","updated":"2016-10-14T01:14:47.503Z","comments":true,"path":"2016/10/10/async-wait/","link":"","permalink":"http://gavin-gong.github.io/2016/10/10/async-wait/","excerpt":"","text":"async/await await只能用于async函数中 await后面一般接一个promise对象，如不是promise对象, 则失去异步调用的作用 async总是返回一个promise对象, 所以你可以在后面接then() 并发1234567async function foo () &#123; let [a, b, c] = await Promise.all([p1, p2, p3]); // a, b, c 是对象promise对象执行后的resolve值 // 或者这样 // const all = Promise.all.bind(Promise); // let [a, b, c] = await all([p1, p2, p3]);&#125; 错误处理123asyncFunction() .then() .catch(err =&gt; console.log(err)) 循环多个await如果要循环多个await 要注意async 的上下文,await要始终保持在它的上下文中, 123456789[1, 2, 3].forEach( v =&gt; &#123; await sleep(1000); // 这里的await并没有在`async`函数上下文中&#125;)// 正确写法, 用for循环for (let i of [1, 2, 3]) &#123; await sleep(1000);&#125; awaitawait后面接一个promise对象, 如果不是则不执行异步, 想到Promise.resolve()可以将转化为promise对象, 试了试如下代码 123456789101112function timeout(ms) &#123; setTimeout(() =&gt; console.log('timeout'), ms)&#125;async function asyncPrint(value, ms) &#123; await Promise.resolve(timeout(ms)); console.log(value)&#125;asyncPrint('hello world', 50); // 'hello world'// 'timeout' 并没有什么卵用.","categories":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://gavin-gong.github.io/tags/es6/"}],"keywords":[{"name":"FE","slug":"FE","permalink":"http://gavin-gong.github.io/categories/FE/"}]}]}